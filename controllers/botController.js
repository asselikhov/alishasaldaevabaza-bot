const { bot, sendInviteLink, getSettings, getWelcomeMessage, getPaidWelcomeMessage, resetSettingsCache } = require('../services/telegram');
const { createPayment, getPayment } = require('../services/yookassa');
const User = require('../models/User');
const Settings = require('../models/Settings');
const { createCanvas } = require('canvas');
const Chart = require('chart.js/auto');

const adminIds = new Set((process.env.ADMIN_CHAT_IDS || '').split(',').map(id => id.trim()));

async function processPayment(ctx, userId, chatId) {
  try {
    const user = await User.findOne({ userId });
    if (user?.paymentStatus === 'succeeded' && user.inviteLink) {
      return ctx.reply('–í—ã —É–∂–µ –æ–ø–ª–∞—Ç–∏–ª–∏ –¥–æ—Å—Ç—É–ø! –í–æ—Ç –≤–∞—à–∞ –æ–¥–Ω–æ—Ä–∞–∑–æ–≤–∞—è —Å—Å—ã–ª–∫–∞:', {
        parse_mode: 'Markdown',
        reply_markup: { inline_keyboard: [[{ text: '–ü—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—å—Å—è', url: user.inviteLink }]] },
      });
    }

    const settings = await getSettings();
    const localPaymentId = require('uuid').v4();
    const payment = await Promise.race([
      createPayment({
        amount: settings.paymentAmount,
        description: '–î–æ—Å—Ç—É–ø –∫ –∑–∞–∫—Ä—ã—Ç–æ–º—É Telegram –∫–∞–Ω–∞–ª—É',
        paymentId: localPaymentId,
        userId,
        returnUrl: `${process.env.RETURN_URL}?paymentId=${localPaymentId}`,
        email: user.email,
      }),
      new Promise((_, reject) => setTimeout(() => reject(new Error('Timeout waiting for Yookassa response')), 15000)),
    ]);

    await User.updateOne({ userId }, { paymentId: payment.id, localPaymentId, paymentStatus: 'pending', chatId, lastActivity: new Date() }, { upsert: true });

    await ctx.reply('–ü–µ—Ä–µ–π–¥–∏—Ç–µ –ø–æ —Å—Å—ã–ª–∫–µ –¥–ª—è –æ–ø–ª–∞—Ç—ã:', {
      parse_mode: 'Markdown',
      reply_markup: { inline_keyboard: [[{ text: '–û–ø–ª–∞—Ç–∏—Ç—å', url: payment.confirmation.confirmation_url }]] },
    });
  } catch (error) {
    console.error(`[PAYMENT] Error for user ${userId}:`, error.message);
    await ctx.reply('–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ –ø–ª–∞—Ç–µ–∂–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ –∏–ª–∏ —Å–≤—è–∂–∏—Ç–µ—Å—å —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π.', {
      reply_markup: { inline_keyboard: [[{ text: 'üí¨ –¢–µ—Ö–ø–æ–¥–¥–µ—Ä–∂–∫–∞', url: (await getSettings()).supportLink }]] },
    });
  }
}

bot.command('checkpayment', async (ctx) => {
  const userId = String(ctx.from.id);
  try {
    console.log(`[CHECKPAYMENT] Processing for user ${userId}`);
    await User.updateOne({ userId }, { lastActivity: new Date() });
    const user = await User.findOne({ userId });
    if (!user || !user.paymentId) return ctx.reply('–£ –≤–∞—Å –Ω–µ—Ç –∞–∫—Ç–∏–≤–Ω—ã—Ö –ø–ª–∞—Ç–µ–∂–µ–π.');

    if (user.paymentStatus === 'succeeded' && user.inviteLink) {
      await ctx.reply(await getPaidWelcomeMessage(), {
        parse_mode: 'Markdown',
        reply_markup: {
          inline_keyboard: [
            [{ text: 'üí¨ –¢–µ—Ö–ø–æ–¥–¥–µ—Ä–∂–∫–∞', url: (await getSettings()).supportLink }, { text: 'üí° –û –∫–∞–Ω–∞–ª–µ', callback_data: 'about' }],
          ],
        },
      });
      await ctx.reply('–í–∞—à–∞ —É–Ω–∏–∫–∞–ª—å–Ω–∞—è –æ–¥–Ω–æ—Ä–∞–∑–æ–≤–∞—è —Å—Å—ã–ª–∫–∞ –¥–ª—è –≤—Å—Ç—É–ø–ª–µ–Ω–∏—è –≤ –∑–∞–∫—Ä—ã—Ç—ã–π –∫–∞–Ω–∞–ª:', {
        parse_mode: 'Markdown',
        reply_markup: { inline_keyboard: [[{ text: '–ü—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—å—Å—è', url: user.inviteLink }]] },
      });
      console.log(`[CHECKPAYMENT] Sent existing invite link for user ${userId}: ${user.inviteLink}`);
      return;
    }

    const payment = await getPayment(user.paymentId);
    if (payment.status === 'succeeded') {
      const inviteLink = await sendInviteLink(user, ctx, user.paymentId);
      await ctx.reply(await getPaidWelcomeMessage(), {
        parse_mode: 'Markdown',
        reply_markup: {
          inline_keyboard: [
            [{ text: 'üí¨ –¢–µ—Ö–ø–æ–¥–¥–µ—Ä–∂–∫–∞', url: (await getSettings()).supportLink }, { text: 'üí° –û –∫–∞–Ω–∞–ª–µ', callback_data: 'about' }],
          ],
        },
      });
      await ctx.reply('–í–∞—à–∞ —É–Ω–∏–∫–∞–ª—å–Ω–∞—è –æ–¥–Ω–æ—Ä–∞–∑–æ–≤–∞—è —Å—Å—ã–ª–∫–∞ –¥–ª—è –≤—Å—Ç—É–ø–ª–µ–Ω–∏—è –≤ –∑–∞–∫—Ä—ã—Ç—ã–π –∫–∞–Ω–∞–ª:', {
        parse_mode: 'Markdown',
        reply_markup: { inline_keyboard: [[{ text: '–ü—Ä–∏—Å–æ–µ–¥–∏–Ω–∏—Ç—å—Å—è', url: inviteLink }]] },
      });
      console.log(`[CHECKPAYMENT] Sent new invite link for user ${userId}: ${inviteLink}`);
    } else {
      await ctx.reply(`–°—Ç–∞—Ç—É—Å –≤–∞—à–µ–≥–æ –ø–ª–∞—Ç–µ–∂–∞: ${payment.status}. –ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –∑–∞–≤–µ—Ä—à–∏—Ç–µ –æ–ø–ª–∞—Ç—É –∏–ª–∏ —Å–≤—è–∂–∏—Ç–µ—Å—å —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π.`, {
        reply_markup: { inline_keyboard: [[{ text: 'üí¨ –¢–µ—Ö–ø–æ–¥–¥–µ—Ä–∂–∫–∞', url: (await getSettings()).supportLink }]] },
      });
    }
  } catch (error) {
    console.error(`[CHECKPAYMENT] Error for user ${userId}:`, error.message);
    await ctx.reply('–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ —Å—Ç–∞—Ç—É—Å–∞ –ø–ª–∞—Ç–µ–∂–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ –∏–ª–∏ —Å–≤—è–∂–∏—Ç–µ—Å—å —Å –ø–æ–¥–¥–µ—Ä–∂–∫–æ–π.', {
      reply_markup: { inline_keyboard: [[{ text: 'üí¨ –¢–µ—Ö–ø–æ–¥–¥–µ—Ä–∂–∫–∞', url: (await getSettings()).supportLink }]] },
    });
  }
});

bot.command('checkuser', async (ctx) => {
  const userId = String(ctx.from.id);
  if (!adminIds.has(userId)) return ctx.reply('–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â—ë–Ω.');
  const targetUserId = ctx.message.text.split(' ')[1];
  if (!targetUserId) return ctx.reply('–£–∫–∞–∂–∏—Ç–µ ID –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è: /checkuser <userId>');

  try {
    console.log(`[CHECKUSER] Checking user ${targetUserId} by admin ${userId}`);
    const user = await User.findOne({ userId: targetUserId });
    if (!user) return ctx.reply(`–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å ${targetUserId} –Ω–µ –Ω–∞–π–¥–µ–Ω.`);

    const channelId = process.env.CHANNEL_ID;
    if (!channelId) return ctx.reply('–û—à–∏–±–∫–∞: ID –∫–∞–Ω–∞–ª–∞ –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω.');

    const isMember = await checkChannelMembership(targetUserId, channelId);
    if (isMember && !user.joinedChannel) {
      await User.updateOne({ userId: targetUserId }, { joinedChannel: true, inviteLinkUsed: true });
      console.log(`[CHECKUSER] Updated joinedChannel to true for user ${targetUserId}`);
    }

    await ctx.reply(
        `–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—å ${targetUserId}:\n` +
        `–ò–º—è: ${user.firstName || 'N/A'}\n` +
        `Username: ${user.username ? '@' + user.username : 'N/A'}\n` +
        `–°—Ç–∞—Ç—É—Å –ø–ª–∞—Ç–µ–∂–∞: ${user.paymentStatus || 'N/A'}\n` +
        `–í—Å—Ç—É–ø–∏–ª –≤ –∫–∞–Ω–∞–ª: ${isMember ? '–î–∞' : '–ù–µ—Ç'}\n` +
        `–°—Å—ã–ª–∫–∞ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∞: ${user.inviteLinkUsed ? '–î–∞' : '–ù–µ—Ç'}\n` +
        `–°—Å—ã–ª–∫–∞: ${user.inviteLink || 'N/A'}`,
        { parse_mode: 'Markdown' }
    );
  } catch (error) {
    console.error(`[CHECKUSER] Error for user ${targetUserId}:`, error.message);
    await ctx.reply('–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø—Ä–æ–≤–µ—Ä–∫–µ —Å—Ç–∞—Ç—É—Å–∞ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è.');
  }
});

bot.start(async (ctx) => {
  const userId = String(ctx.from.id);
  const chatId = String(ctx.chat.id);
  const { first_name: firstName, username, phone_number: phoneNumber } = ctx.from;

  try {
    console.log(`[START] Received /start command from user ${userId}`);
    let user = await User.findOne({ userId });
    console.log(`[START] User ${userId} found or to be created: ${user ? 'exists' : 'new'}`);
    if (!user) {
      user = await User.create({ userId, chatId, firstName, username, phoneNumber, lastActivity: new Date() });
      console.log(`[START] User created: ${JSON.stringify(user)}`);
    } else {
      await User.updateOne({ userId }, { lastActivity: new Date() });
    }

    const settings = await getSettings();
    console.log(`[START] Sending reply to ${userId}`);
    ctx.session = ctx.session || {};
    ctx.session.navHistory = ctx.session.navHistory || [];
    const inlineKeyboard = user.paymentStatus === 'succeeded' ? [
      [
        { text: 'üí¨ –¢–µ—Ö–ø–æ–¥–¥–µ—Ä–∂–∫–∞', url: settings.supportLink },
        { text: 'üí° –û –∫–∞–Ω–∞–ª–µ', callback_data: 'about' },
        ...(adminIds.has(userId) ? [{ text: 'üëë –ê–¥–º–∏–Ω–∫–∞', callback_data: 'admin_panel' }] : []),
      ],
    ] : [
      [
        { text: `üî• –ö—É–ø–∏—Ç—å –∑–∞ ${settings.paymentAmount}—Ä.`, callback_data: 'buy' },
        { text: 'üí¨ –¢–µ—Ö–ø–æ–¥–¥–µ—Ä–∂–∫–∞', url: settings.supportLink },
      ],
      [
        { text: 'üí° –û –∫–∞–Ω–∞–ª–µ', callback_data: 'about' },
        ...(adminIds.has(userId) ? [{ text: 'üëë –ê–¥–º–∏–Ω–∫–∞', callback_data: 'admin_panel' }] : []),
      ],
    ];

    const sentMessage = await ctx.replyWithMarkdown(
        user.paymentStatus === 'succeeded' ? await getPaidWelcomeMessage() : await getWelcomeMessage(),
        {
          reply_markup: { inline_keyboard: inlineKeyboard },
        }
    );
    ctx.session.currentMessageId = sentMessage.message_id;
    console.log(`[START] Reply sent to ${userId}, stored message_id: ${ctx.session.currentMessageId}`);
  } catch (error) {
    console.error(`[START] Error for user ${userId}:`, error.message);
    await ctx.reply('–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π —Å–Ω–æ–≤–∞ –∏–ª–∏ —Å–≤—è–∂–∏—Ç–µ—Å—å —Å –Ω–∞–º–∏.');
  }
});

// –£–ª—É—á—à–µ–Ω–Ω–∞—è —Ñ—É–Ω–∫—Ü–∏—è –¥–ª—è —ç–∫—Ä–∞–Ω–∏—Ä–æ–≤–∞–Ω–∏—è —Å–ø–µ—Ü–∏–∞–ª—å–Ω—ã—Ö —Å–∏–º–≤–æ–ª–æ–≤ –≤ MarkdownV2
function escapeMarkdownV2(text) {
  if (!text || typeof text !== 'string') return text || '';
  console.log(`[ESCAPE_MARKDOWNV2] Input: ${text}`);
  const escaped = text.replace(/([_*[\]()~`>#+\-=|{}\.!\\])/g, '\\$1').replace(/(?<!\d)\.(?!\d)/g, '\\.');
  console.log(`[ESCAPE_MARKDOWNV2] Output: ${escaped}`);
  return escaped;
}

async function generateActivityChart(dailyActivity) {
  try {
    console.log(`[GENERATE_ACTIVITY_CHART] Input data: ${JSON.stringify(dailyActivity)}`);
    if (!Array.isArray(dailyActivity) || dailyActivity.some(entry => !entry.date || typeof entry.count !== 'number')) {
      throw new Error('Invalid dailyActivity data format');
    }

    const canvas = createCanvas(800, 400);
    const ctx = canvas.getContext('2d');

    const labels = dailyActivity.map(entry => {
      const [year, month, day] = entry.date.split('-');
      return `${day}.${month}`;
    });
    const data = dailyActivity.map(entry => entry.count);

    console.log(`[GENERATE_ACTIVITY_CHART] Labels: ${JSON.stringify(labels)}, Data: ${JSON.stringify(data)}`);

    const gradient = ctx.createLinearGradient(0, 0, 0, 400);
    gradient.addColorStop(0, '#1E1E1E');
    gradient.addColorStop(1, '#2D2D2D');
    ctx.fillStyle = gradient;
    ctx.fillRect(0, 0, 800, 400);

    new Chart(ctx, {
      type: 'line',
      data: {
        labels: labels,
        datasets: [{
          data: data,
          borderColor: '#3B82F6',
          borderWidth: 3,
          pointBackgroundColor: '#3B82F6',
          pointRadius: 4,
          pointHoverRadius: 6,
          tension: 0.4,
          fill: {
            target: 'origin',
            above: 'rgba(59, 130, 246, 0.1)',
          },
        }],
      },
      options: {
        responsive: true,
        animation: {
          duration: 1000,
          easing: 'easeOutQuart',
        },
        plugins: {
          legend: {
            display: false,
          },
          title: {
            display: true,
            text: '–ê–∫—Ç–∏–≤–Ω–æ—Å—Ç—å –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –∑–∞ –ò—é–ª—å 2025',
            font: { size: 16, family: 'Inter, sans-serif', weight: '600' },
            color: '#A0AEC0',
            padding: { top: 10, bottom: 10 },
          },
        },
        scales: {
          x: {
            title: {
              display: true,
              text: '–î–∞—Ç–∞',
              font: { size: 12, family: 'Inter, sans-serif', weight: '500' },
              color: '#A0AEC0',
            },
            ticks: {
              color: '#A0AEC0',
              font: { size: 10, family: 'Inter, sans-serif' },
              maxRotation: 45,
              minRotation: 45,
            },
            grid: {
              color: 'rgba(255, 255, 255, 0.05)',
              borderColor: 'rgba(255, 255, 255, 0.2)',
              drawBorder: false,
            },
          },
          y: {
            title: {
              display: true,
              text: '–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏',
              font: { size: 12, family: 'Inter, sans-serif', weight: '500' },
              color: '#A0AEC0',
            },
            ticks: {
              color: '#A0AEC0',
              font: { size: 10, family: 'Inter, sans-serif' },
              beginAtZero: true,
              stepSize: 1,
              precision: 0,
              callback: (value) => Number.isInteger(value) ? value : null,
            },
            grid: {
              color: 'rgba(255, 255, 255, 0.05)',
              borderColor: 'rgba(255, 255, 255, 0.2)',
              drawBorder: false,
            },
            min: 0,
            max: Math.max(...data, 10) + 5,
          },
        },
        elements: {
          line: {
            borderJoinStyle: 'round',
            borderCapStyle: 'round',
          },
          point: {
            hoverBorderWidth: 2,
          },
        },
      },
    });

    const buffer = canvas.toBuffer('image/png');
    console.log(`[GENERATE_ACTIVITY_CHART] Chart generated successfully for ${dailyActivity.length} data points`);
    return buffer;
  } catch (error) {
    console.error(`[GENERATE_ACTIVITY_CHART] Error: ${error.message}`, error.stack);
    throw error;
  }
}

async function checkChannelMembership(userId, channelId, retries = 3, delay = 1000) {
  for (let attempt = 1; attempt <= retries; attempt++) {
    try {
      console.log(`[CHECK_CHANNEL_MEMBERSHIP] Attempt ${attempt} for user ${userId}`);
      const chatMember = await bot.telegram.getChatMember(channelId, userId);
      const isMember = ['member', 'administrator', 'creator'].includes(chatMember.status);
      console.log(`[CHECK_CHANNEL_MEMBERSHIP] User ${userId} status: ${chatMember.status}, isMember: ${isMember}`);
      return isMember;
    } catch (error) {
      console.error(`[CHECK_CHANNEL_MEMBERSHIP] Attempt ${attempt} failed for user ${userId}: ${error.message}`);
      if (attempt < retries && error.message.includes('Too Many Requests')) {
        await new Promise(resolve => setTimeout(resolve, delay));
        continue;
      }
      return false;
    }
  }
  console.error(`[CHECK_CHANNEL_MEMBERSHIP] All ${retries} attempts failed for user ${userId}`);
  return false;
}

bot.action('stats', async (ctx) => {
  await ctx.answerCbQuery();
  const userId = String(ctx.from.id);
  const chatId = String(ctx.chat.id);
  if (!adminIds.has(userId)) return ctx.reply('–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â—ë–Ω.');

  try {
    console.log(`[STATS] Processing for user ${userId}`);
    await User.updateOne({ userId }, { lastActivity: new Date() });

    const totalUsers = await User.countDocuments();
    const paidUsers = await User.countDocuments({ paymentStatus: 'succeeded' });

    const today = new Date();
    today.setHours(23, 59, 59, 999);
    const startOfMonth = new Date(today.getFullYear(), today.getMonth(), 1);
    startOfMonth.setHours(0, 0, 0, 0);

    const dailyActivity = await User.aggregate([
      {
        $match: {
          lastActivity: { $gte: startOfMonth, $lte: today },
        },
      },
      {
        $group: {
          _id: {
            $dateToString: { format: '%Y-%m-%d', date: '$lastActivity', timezone: 'Europe/Moscow' },
          },
          count: { $sum: 1 },
        },
      },
      {
        $sort: { '_id': 1 },
      },
    ]);

    const dateArray = [];
    let currentDate = new Date(startOfMonth);
    while (currentDate <= today) {
      const dateStr = currentDate.toLocaleDateString('ru-RU', { timeZone: 'Europe/Moscow', year: 'numeric', month: '2-digit', day: '2-digit' }).split('.').reverse().join('-');
      const found = dailyActivity.find(d => d._id === dateStr);
      dateArray.push({ date: dateStr, count: found ? found.count : 0 });
      currentDate.setDate(currentDate.getDate() + 1);
    }

    console.log(`[STATS] Generated dateArray: ${JSON.stringify(dateArray)}`);

    const chartBuffer = await generateActivityChart(dateArray);

    ctx.session = ctx.session || {};
    ctx.session.navHistory = ctx.session.navHistory || [];
    ctx.session.navHistory.push('admin_panel');

    const sentMessage = await ctx.replyWithPhoto(
        { source: chartBuffer },
        {
          caption: `üìä –°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞:\n‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ\n–ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π: ${totalUsers} | –ü–æ–¥–ø–∏—Å—á–∏–∫–æ–≤: ${paidUsers}`,
          parse_mode: 'Markdown',
          reply_markup: { inline_keyboard: [[{ text: '‚Ü©Ô∏è –ù–∞–∑–∞–¥', callback_data: 'back' }]] },
        }
    );
    ctx.session.currentMessageId = sentMessage.message_id;
    console.log(`[STATS] Sent photo with stats caption, message_id: ${sentMessage.message_id} for user ${userId}`);
  } catch (error) {
    console.error(`[STATS] Error for user ${userId}: ${error.message}`, error.stack);
    await ctx.reply('–û—à–∏–±–∫–∞ –ø—Ä–∏ –ø–æ–ª—É—á–µ–Ω–∏–∏ —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.');
  }
});

bot.action('admin_panel', async (ctx) => {
  await ctx.answerCbQuery();
  const userId = String(ctx.from.id);
  const chatId = String(ctx.chat.id);
  if (!adminIds.has(userId)) return ctx.reply('–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â—ë–Ω.');

  try {
    console.log(`[ADMIN_PANEL] Processing for user ${userId}`);
    await User.updateOne({ userId }, { lastActivity: new Date() });
    ctx.session = ctx.session || {};
    ctx.session.navHistory = ctx.session.navHistory || [];
    ctx.session.navHistory.push('start');

    const replyMarkup = {
      inline_keyboard: [
        [{ text: '–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å', callback_data: 'edit' }],
        [{ text: '–í—ã–≥—Ä—É–∑–∏—Ç—å –ø–æ–¥–ø–∏—Å—á–∏–∫–æ–≤', callback_data: 'export_subscribers' }],
        [{ text: '–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞', callback_data: 'stats' }],
        [{ text: '–û–±–Ω–æ–≤–∏—Ç—å —Å—Ç–∞—Ç—É—Å—ã –≤—Å—Ç—É–ø–ª–µ–Ω–∏—è', callback_data: 'update_joined_status' }],
        [{ text: '‚Ü©Ô∏è –ù–∞–∑–∞–¥', callback_data: 'back' }],
      ],
    };

    let messageId = ctx.message?.message_id || ctx.session.currentMessageId;
    if (messageId) {
      try {
        await ctx.telegram.editMessageText(chatId, messageId, undefined, '–ê–¥–º–∏–Ω–∫–∞:\n‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ', {
          parse_mode: 'Markdown',
          reply_markup: replyMarkup,
        });
        ctx.session.currentMessageId = messageId;
        console.log(`[ADMIN_PANEL] Edited message ${messageId} for user ${userId}`);
      } catch (editError) {
        console.warn(`[ADMIN_PANEL] Failed to edit message ${messageId} for user ${userId}:`, editError.message);
        const sentMessage = await ctx.reply('–ê–¥–º–∏–Ω–∫–∞:\n‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ', {
          parse_mode: 'Markdown',
          reply_markup: replyMarkup,
        });
        ctx.session.currentMessageId = sentMessage.message_id;
        console.log(`[ADMIN_PANEL] Sent new message ${ctx.session.currentMessageId} for user ${userId}`);
      }
    } else {
      console.warn(`[ADMIN_PANEL] No valid message_id for user ${userId}, sending new message`);
      const sentMessage = await ctx.reply('–ê–¥–º–∏–Ω–∫–∞:\n‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ', {
        parse_mode: 'Markdown',
        reply_markup: replyMarkup,
      });
      ctx.session.currentMessageId = sentMessage.message_id;
      console.log(`[ADMIN_PANEL] Sent new message ${ctx.session.currentMessageId} for user ${userId}`);
    }
  } catch (error) {
    console.error(`[ADMIN_PANEL] Error for user ${userId}:`, error.stack);
    await ctx.reply('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ—Ç–∫—Ä—ã—Ç–∏–∏ –∞–¥–º–∏–Ω-–ø–∞–Ω–µ–ª–∏.');
  }
});

bot.action('update_joined_status', async (ctx) => {
  await ctx.answerCbQuery();
  const userId = String(ctx.from.id);
  if (!adminIds.has(userId)) return ctx.reply('–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â—ë–Ω.');

  try {
    console.log(`[UPDATE_JOINED_STATUS] Processing for user ${userId}`);
    await User.updateOne({ userId }, { lastActivity: new Date() });

    const users = await User.find({ paymentStatus: 'succeeded' }).lean();
    if (!users.length) return ctx.reply('–ù–µ—Ç –æ–ø–ª–∞—á–µ–Ω–Ω—ã—Ö –ø–æ–¥–ø–∏—Å—á–∏–∫–æ–≤ –¥–ª—è –æ–±–Ω–æ–≤–ª–µ–Ω–∏—è.');

    const channelId = process.env.CHANNEL_ID;
    if (!channelId) {
      console.error(`[UPDATE_JOINED_STATUS] CHANNEL_ID not set`);
      return ctx.reply('–û—à–∏–±–∫–∞: ID –∫–∞–Ω–∞–ª–∞ –Ω–µ –Ω–∞—Å—Ç—Ä–æ–µ–Ω.');
    }

    let updatedCount = 0;
    const notJoinedUsers = [];
    for (const user of users) {
      const isMember = await checkChannelMembership(user.userId, channelId);
      if (isMember && !user.joinedChannel) {
        await User.updateOne({ userId: user.userId }, { joinedChannel: true, inviteLinkUsed: true });
        updatedCount++;
        console.log(`[UPDATE_JOINED_STATUS] Updated user ${user.userId} to joinedChannel: true`);
      } else if (!isMember) {
        notJoinedUsers.push({ userId: user.userId, firstName: user.firstName, username: user.username });
      }
    }

    await ctx.reply(
        `–û–±–Ω–æ–≤–ª–µ–Ω–æ —Å—Ç–∞—Ç—É—Å–æ–≤ –≤—Å—Ç—É–ø–ª–µ–Ω–∏—è: ${updatedCount} –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π.\n` +
        (notJoinedUsers.length > 0
            ? `–ù–µ –≤—Å—Ç—É–ø–∏–ª–∏ –≤ –∫–∞–Ω–∞–ª:\n${notJoinedUsers.map(u => `${u.firstName} (@${u.username || '–±–µ–∑ username'}, ID: ${u.userId})`).join('\n')}`
            : '–í—Å–µ –æ–ø–ª–∞—á–µ–Ω–Ω—ã–µ –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–∏ –≤—Å—Ç—É–ø–∏–ª–∏ –≤ –∫–∞–Ω–∞–ª.')
    );
    console.log(`[UPDATE_JOINED_STATUS] Updated ${updatedCount} users' joinedChannel status, not joined: ${JSON.stringify(notJoinedUsers)}`);
  } catch (error) {
    console.error(`[UPDATE_JOINED_STATUS] Error for user ${userId}:`, error.message);
    await ctx.reply('–û—à–∏–±–∫–∞ –ø—Ä–∏ –æ–±–Ω–æ–≤–ª–µ–Ω–∏–∏ —Å—Ç–∞—Ç—É—Å–æ–≤ –≤—Å—Ç—É–ø–ª–µ–Ω–∏—è. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.');
  }
});

bot.action('export_subscribers', async (ctx) => {
  await ctx.answerCbQuery();
  const userId = String(ctx.from.id);
  if (!adminIds.has(userId)) return ctx.reply('–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â—ë–Ω.');

  try {
    console.log(`[EXPORT_SUBSCRIBERS] Processing for user ${userId}`);
    await User.updateOne({ userId }, { lastActivity: new Date() });
    const users = await User.find({ paymentStatus: 'succeeded' }).lean();
    if (!users.length) return ctx.reply('–ù–µ—Ç –æ–ø–ª–∞—á–µ–Ω–Ω—ã—Ö –ø–æ–¥–ø–∏—Å—á–∏–∫–æ–≤ –¥–ª—è –≤—ã–≥—Ä—É–∑–∫–∏.');

    const channelId = process.env.CHANNEL_ID;
    if (channelId) {
      for (const user of users) {
        const isMember = await checkChannelMembership(user.userId, channelId);
        if (isMember && !user.joinedChannel) {
          await User.updateOne({ userId: user.userId }, { joinedChannel: true, inviteLinkUsed: true });
          console.log(`[EXPORT_SUBSCRIBERS] Updated user ${user.userId} to joinedChannel: true`);
        }
      }
    } else {
      console.warn(`[EXPORT_SUBSCRIBERS] CHANNEL_ID not set, skipping membership check`);
    }

    console.log(`[EXPORT_SUBSCRIBERS] Raw users data: ${JSON.stringify(users.map(u => ({ userId: u.userId, firstName: u.firstName, username: u.username, inviteLink: u.inviteLink, joinedChannel: u.joinedChannel })))}`);

    const ExcelJS = require('exceljs');
    const workbook = new ExcelJS.Workbook();
    const worksheet = workbook.addWorksheet('Subscribers', { properties: { defaultRowHeight: 20 } });
    worksheet.columns = [
      { header: 'ID –ü–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª—è', key: 'userId', width: 20 },
      { header: 'ID –ß–∞—Ç–∞', key: 'chatId', width: 20 },
      { header: '–°—Ç–∞—Ç—É—Å –ü–ª–∞—Ç–µ–∂–∞', key: 'paymentStatus', width: 15 },
      { header: 'ID –ü–ª–∞—Ç–µ–∂–∞', key: 'paymentId', width: 30 },
      { header: '–õ–æ–∫–∞–ª—å–Ω—ã–π ID –ü–ª–∞—Ç–µ–∂–∞', key: 'localPaymentId', width: 30 },
      { header: '–í—Å—Ç—É–ø–∏–ª –≤ –ö–∞–Ω–∞–ª', key: 'joinedChannel', width: 15 },
      { header: '–°—Å—ã–ª–∫–∞ –ü—Ä–∏–≥–ª–∞—à–µ–Ω–∏—è', key: 'inviteLink', width: 40 }, // –û–±–Ω–æ–≤–ª–µ–Ω–æ –Ω–∞–∑–≤–∞–Ω–∏–µ –∫–ª—é—á–∞
      { header: '–°—Ä–æ–∫ –°—Å—ã–ª–∫–∏', key: 'inviteLinkExpires', width: 20 },
      { header: '–ò–º—è', key: 'firstName', width: 20 },
      { header: 'Username', key: 'username', width: 20 },
      { header: '–¢–µ–ª–µ—Ñ–æ–Ω', key: 'phoneNumber', width: 15 },
      { header: 'Email', key: 'email', width: 30 },
      { header: '–î–∞—Ç–∞ –ü–ª–∞—Ç–µ–∂–∞', key: 'paymentDate', width: 20 },
      { header: '–î–æ–∫—É–º–µ–Ω—Ç –ü–ª–∞—Ç–µ–∂–∞', key: 'paymentDocument', width: 40 },
      { header: '–ü–æ—Å–ª–µ–¥–Ω—è—è –ê–∫—Ç–∏–≤–Ω–æ—Å—Ç—å', key: 'lastActivity', width: 20 },
    ];

    worksheet.getRow(1).font = { bold: true, size: 12 };
    worksheet.getRow(1).fill = { type: 'pattern', pattern: 'solid', fgColor: { argb: 'FFADD8E6' } };
    worksheet.getRow(1).alignment = { vertical: 'middle', horizontal: 'center' };
    worksheet.getRow(1).height = 30;

    users.forEach(user => worksheet.addRow({
      userId: user.userId || 'N/A',
      chatId: user.chatId || 'N/A',
      paymentStatus: user.paymentStatus || 'N/A',
      paymentId: user.paymentId || 'N/A',
      localPaymentId: user.localPaymentId || 'N/A',
      joinedChannel: user.joinedChannel ? '–î–∞' : '–ù–µ—Ç',
      inviteLink: user.inviteLink || 'N/A', // –ò—Å–ø–æ–ª—å–∑—É–µ–º –ø–æ–ª–µ inviteLink –∏–∑ –±–∞–∑—ã –¥–∞–Ω–Ω—ã—Ö
      inviteLinkExpires: user.inviteLinkExpires ? new Date(user.inviteLinkExpires).toLocaleString('ru-RU') : 'N/A',
      firstName: user.firstName || 'N/A',
      username: user.username ? `@${user.username}` : 'N/A',
      phoneNumber: user.phoneNumber || 'N/A',
      email: user.email || 'N/A',
      paymentDate: user.paymentDate ? user.paymentDate.toLocaleString('ru-RU') : 'N/A',
      paymentDocument: user.paymentDocument || 'N/A',
      lastActivity: user.lastActivity ? user.lastActivity.toLocaleString('ru-RU') : 'N/A',
    }));

    worksheet.eachRow({ includeEmpty: false }, (row, rowNumber) => {
      if (rowNumber > 1) {
        row.font = { size: 11 };
        row.alignment = { vertical: 'middle', horizontal: 'left', wrapText: true };
        row.height = 25;
      }
    });

    ['M', 'O'].forEach(col => worksheet.getColumn(col).numFmt = 'dd.mm.yyyy hh:mm:ss');
    worksheet.columns.forEach(column => {
      let maxLength = 0;
      column.eachCell({ includeEmpty: true }, cell => maxLength = Math.max(maxLength, cell.value ? String(cell.value).length : 10));
      column.width = Math.min(maxLength + 2, 50);
    });

    const buffer = await workbook.xlsx.writeBuffer();
    await ctx.replyWithDocument({ source: buffer, filename: `subscribers_${new Date().toISOString().split('T')[0]}.xlsx` });
  } catch (error) {
    console.error(`[EXPORT_SUBSCRIBERS] Error for user ${userId}:`, error.message);
    await ctx.reply('–û—à–∏–±–∫–∞ –ø–µ—Ä–µ–¥–∞—á–∏ –ø–æ–¥–ø–∏—Å—á–∏–∫–æ–≤. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.');
  }
});

bot.action('back', async (ctx) => {
  await ctx.answerCbQuery();
  const userId = String(ctx.from.id);
  const chatId = String(ctx.chat.id);
  try {
    console.log(`[BACK] Processing for user ${userId}`);
    await User.updateOne({ userId }, { lastActivity: new Date() });
    ctx.session = ctx.session || {};
    ctx.session.navHistory = ctx.session.navHistory || [];
    const lastAction = ctx.session.navHistory.pop() || 'start';

    if (lastAction === 'start') {
      const settings = await getSettings();
      const user = await User.findOne({ userId });
      const inlineKeyboard = user.paymentStatus === 'succeeded' ? [
        [
          { text: 'üí¨ –¢–µ—Ö–ø–æ–¥–¥–µ—Ä–∂–∫–∞', url: settings.supportLink },
          { text: 'üí° –û –∫–∞–Ω–∞–ª–µ', callback_data: 'about' },
          ...(adminIds.has(userId) ? [{ text: 'üëë –ê–¥–º–∏–Ω–∫–∞', callback_data: 'admin_panel' }] : []),
        ],
      ] : [
        [
          { text: `üî• –ö—É–ø–∏—Ç—å –∑–∞ ${settings.paymentAmount}—Ä.`, callback_data: 'buy' },
          { text: 'üí¨ –¢–µ—Ö–ø–æ–¥–¥–µ—Ä–∂–∫–∞', url: settings.supportLink },
        ],
        [
          { text: 'üí° –û –∫–∞–Ω–∞–ª–µ', callback_data: 'about' },
          ...(adminIds.has(userId) ? [{ text: 'üëë –ê–¥–º–∏–Ω–∫–∞', callback_data: 'admin_panel' }] : []),
        ],
      ];

      const newText = user.paymentStatus === 'succeeded' ? await getPaidWelcomeMessage() : await getWelcomeMessage();
      const messageId = ctx.message?.message_id || ctx.session.currentMessageId;

      if (!messageId) {
        console.warn(`[BACK] No message_id available for user ${userId}, sending new message`);
        const sentMessage = await ctx.replyWithMarkdown(newText, { reply_markup: { inline_keyboard: inlineKeyboard } });
        ctx.session.currentMessageId = sentMessage.message_id;
        console.log(`[BACK] Sent new message ${ctx.session.currentMessageId} for user ${userId}`);
        return;
      }

      try {
        await ctx.telegram.editMessageText(chatId, messageId, undefined, newText, {
          parse_mode: 'Markdown',
          reply_markup: { inline_keyboard: inlineKeyboard },
        });
        console.log(`[BACK] Edited message ${messageId} for user ${userId}`);
      } catch (editError) {
        console.warn(`[BACK] Failed to edit message ${messageId} for user ${userId}:`, editError.message);
        if (editError.message.includes('message is not modified')) {
          console.log(`[BACK] Message ${messageId} not modified, keeping current state for user ${userId}`);
          return;
        }
        const sentMessage = await ctx.replyWithMarkdown(newText, { reply_markup: { inline_keyboard: inlineKeyboard } });
        ctx.session.currentMessageId = sentMessage.message_id;
        console.log(`[BACK] Sent new message ${ctx.session.currentMessageId} for user ${userId}`);
      }
    } else if (lastAction === 'admin_panel') {
      const messageId = ctx.message?.message_id || ctx.session.currentMessageId;
      const replyMarkup = {
        inline_keyboard: [
          [{ text: '–†–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å', callback_data: 'edit' }],
          [{ text: '–í—ã–≥—Ä—É–∑–∏—Ç—å –ø–æ–¥–ø–∏—Å—á–∏–∫–æ–≤', callback_data: 'export_subscribers' }],
          [{ text: '–°—Ç–∞—Ç–∏—Å—Ç–∏–∫–∞', callback_data: 'stats' }],
          [{ text: '–û–±–Ω–æ–≤–∏—Ç—å —Å—Ç–∞—Ç—É—Å—ã –≤—Å—Ç—É–ø–ª–µ–Ω–∏—è', callback_data: 'update_joined_status' }],
          [{ text: '‚Ü©Ô∏è –ù–∞–∑–∞–¥', callback_data: 'back' }],
        ],
      };

      if (!messageId) {
        console.warn(`[BACK] No message_id available for user ${userId}, sending new message`);
        const sentMessage = await ctx.reply('–ê–¥–º–∏–Ω–∫–∞:\n‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ', {
          parse_mode: 'Markdown',
          reply_markup: replyMarkup,
        });
        ctx.session.currentMessageId = sentMessage.message_id;
        console.log(`[BACK] Sent new message ${ctx.session.currentMessageId} for user ${userId}`);
        return;
      }

      try {
        await ctx.telegram.editMessageText(chatId, messageId, undefined, '–ê–¥–º–∏–Ω–∫–∞:\n‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ', {
          parse_mode: 'Markdown',
          reply_markup: replyMarkup,
        });
        console.log(`[BACK] Edited message ${messageId} for user ${userId}`);
      } catch (editError) {
        console.warn(`[BACK] Failed to edit message ${messageId} for user ${userId}:`, editError.message);
        if (editError.message.includes('message is not modified')) {
          console.log(`[BACK] Message ${messageId} not modified, keeping current state for user ${userId}`);
          return;
        }
        const sentMessage = await ctx.reply('–ê–¥–º–∏–Ω–∫–∞:\n‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ‚ûñ', {
          parse_mode: 'Markdown',
          reply_markup: replyMarkup,
        });
        ctx.session.currentMessageId = sentMessage.message_id;
        console.log(`[BACK] Sent new message ${ctx.session.currentMessageId} for user ${userId}`);
      }
    }
  } catch (error) {
    console.error(`[BACK] Error for user ${userId}:`, error.stack);
    await ctx.reply('–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.');
  }
});

bot.action('edit', async (ctx) => {
  await ctx.answerCbQuery();
  const userId = String(ctx.from.id);
  const chatId = String(ctx.chat.id);
  if (!adminIds.has(userId)) return ctx.reply('–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â—ë–Ω.');

  try {
    console.log(`[EDIT] Processing for user ${userId}`);
    await User.updateOne({ userId }, { lastActivity: new Date() });
    ctx.session = ctx.session || {};
    ctx.session.navHistory = ctx.session.navHistory || [];
    ctx.session.navHistory.push('admin_panel');

    const replyMarkup = {
      inline_keyboard: [
        [{ text: '–û –∫–∞–Ω–∞–ª–µ', callback_data: 'edit_channel' }],
        [{ text: '–¢–µ—Ö–ø–æ–¥–¥–µ—Ä–∂–∫–∞', callback_data: 'edit_support' }],
        [{ text: '–ü—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏–µ', callback_data: 'edit_welcome' }],
        [{ text: '–°—É–º–º–∞ –æ–ø–ª–∞—Ç—ã', callback_data: 'edit_payment_amount' }],
        [{ text: '–ü—Ä–∏–≤–µ—Ç—Å—Ç–≤–∏–µ –ø–æ—Å–ª–µ –æ–ø–ª–∞—Ç—ã', callback_data: 'edit_paid_welcome' }],
        [{ text: '‚Ü©Ô∏è –ù–∞–∑–∞–¥', callback_data: 'back' }],
      ],
    };

    let messageId = ctx.message?.message_id || ctx.session.currentMessageId;
    if (messageId) {
      try {
        await ctx.telegram.editMessageText(chatId, messageId, undefined, '–í—ã–±–µ—Ä–∏—Ç–µ, —á—Ç–æ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å:', {
          parse_mode: 'Markdown',
          reply_markup: replyMarkup,
        });
        ctx.session.currentMessageId = messageId;
        console.log(`[EDIT] Edited message ${messageId} for user ${userId}`);
      } catch (editError) {
        console.warn(`[EDIT] Failed to edit message ${messageId} for user ${userId}:`, editError.message);
        const sentMessage = await ctx.reply('–í—ã–±–µ—Ä–∏—Ç–µ, —á—Ç–æ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å:', {
          parse_mode: 'Markdown',
          reply_markup: replyMarkup,
        });
        ctx.session.currentMessageId = sentMessage.message_id;
        console.log(`[EDIT] Sent new message ${ctx.session.currentMessageId} for user ${userId}`);
      }
    } else {
      console.warn(`[EDIT] No valid message_id for user ${userId}, sending new message`);
      const sentMessage = await ctx.reply('–í—ã–±–µ—Ä–∏—Ç–µ, —á—Ç–æ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞—Ç—å:', {
        parse_mode: 'Markdown',
        reply_markup: replyMarkup,
      });
      ctx.session.currentMessageId = sentMessage.message_id;
      console.log(`[EDIT] Sent new message ${ctx.session.currentMessageId} for user ${userId}`);
    }
  } catch (error) {
    console.error(`[EDIT] Error for user ${userId}:`, error.stack);
    await ctx.reply('–û—à–∏–±–∫–∞ –ø—Ä–∏ –≤—ã–±–æ—Ä–µ —Ä–µ–¥–∞–∫—Ç–∏—Ä–æ–≤–∞–Ω–∏—è.');
  }
});

bot.action('edit_channel', async (ctx) => {
  await ctx.answerCbQuery();
  const userId = String(ctx.from.id);
  if (!adminIds.has(userId)) return ctx.reply('–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â—ë–Ω.');

  try {
    console.log(`[EDIT_CHANNEL] Processing for user ${userId}`);
    await User.updateOne({ userId }, { lastActivity: new Date() });
    ctx.session = ctx.session || {};
    ctx.session.editing = 'channelDescription';
    await ctx.reply('–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤–æ–µ –æ–ø–∏—Å–∞–Ω–∏–µ –∫–∞–Ω–∞–ª–∞:');
  } catch (error) {
    console.error(`[EDIT_CHANNEL] Error for user ${userId}:`, error.stack);
    await ctx.reply('–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—Ä–æ—Å–µ –æ–ø–∏—Å–∞–Ω–∏—è –∫–∞–Ω–∞–ª–∞.');
  }
});

bot.action('edit_support', async (ctx) => {
  await ctx.answerCbQuery();
  const userId = String(ctx.from.id);
  if (!adminIds.has(userId)) return ctx.reply('–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â—ë–Ω.');

  try {
    console.log(`[EDIT_SUPPORT] Processing for user ${userId}`);
    await User.updateOne({ userId }, { lastActivity: new Date() });
    ctx.session = ctx.session || {};
    ctx.session.editing = 'supportLink';
    await ctx.reply('–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤—ã–π Telegram-username (–Ω–∞–ø—Ä–∏–º–µ—Ä, @Username) –∏–ª–∏ URL —Ç–µ—Ö–ø–æ–¥–¥–µ—Ä–∂–∫–∏:');
  } catch (error) {
    console.error(`[EDIT_SUPPORT] Error for user ${userId}:`, error.stack);
    await ctx.reply('–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—Ä–æ—Å–µ —Å—Å—ã–ª–∫–∏ —Ç–µ—Ö–ø–æ–¥–¥–µ—Ä–∂–∫–∏.');
  }
});

bot.action('edit_welcome', async (ctx) => {
  await ctx.answerCbQuery();
  const userId = String(ctx.from.id);
  if (!adminIds.has(userId)) return ctx.reply('–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â—ë–Ω.');

  try {
    console.log(`[EDIT_WELCOME] Processing for user ${userId}`);
    await User.updateOne({ userId }, { lastActivity: new Date() });
    ctx.session = ctx.session || {};
    ctx.session.editing = 'welcomeMessage';
    await ctx.reply('–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤–æ–µ –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ:');
  } catch (error) {
    console.error(`[EDIT_WELCOME] Error for user ${userId}:`, error.stack);
    await ctx.reply('–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—Ä–æ—Å–µ –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è.');
  }
});

bot.action('edit_payment_amount', async (ctx) => {
  await ctx.answerCbQuery();
  const userId = String(ctx.from.id);
  if (!adminIds.has(userId)) return ctx.reply('–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â—ë–Ω.');

  try {
    console.log(`[EDIT_PAYMENT_AMOUNT] Processing for user ${userId}`);
    await User.updateOne({ userId }, { lastActivity: new Date() });
    ctx.session = ctx.session || {};
    ctx.session.editing = 'paymentAmount';
    await ctx.reply('–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤—É—é —Å—É–º–º—É –æ–ø–ª–∞—Ç—ã –≤ —Ä—É–±–ª—è—Ö (–Ω–∞–ø—Ä–∏–º–µ—Ä, 499):');
  } catch (error) {
    console.error(`[EDIT_PAYMENT_AMOUNT] Error for user ${userId}:`, error.stack);
    await ctx.reply('–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—Ä–æ—Å–µ —Å—É–º–º—ã –æ–ø–ª–∞—Ç—ã.');
  }
});

bot.action('edit_paid_welcome', async (ctx) => {
  await ctx.answerCbQuery();
  const userId = String(ctx.from.id);
  if (!adminIds.has(userId)) return ctx.reply('–î–æ—Å—Ç—É–ø –∑–∞–ø—Ä–µ—â—ë–Ω.');

  try {
    console.log(`[EDIT_PAID_WELCOME] Processing for user ${userId}`);
    await User.updateOne({ userId }, { lastActivity: new Date() });
    ctx.session = ctx.session || {};
    ctx.session.editing = 'paidWelcomeMessage';
    await ctx.reply('–í–≤–µ–¥–∏—Ç–µ –Ω–æ–≤–æ–µ –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–ª—è –ø–æ–ª—å–∑–æ–≤–∞—Ç–µ–ª–µ–π –ø–æ—Å–ª–µ –æ–ø–ª–∞—Ç—ã:');
  } catch (error) {
    console.error(`[EDIT_PAID_WELCOME] Error for user ${userId}:`, error.stack);
    await ctx.reply('–û—à–∏–±–∫–∞ –ø—Ä–∏ –∑–∞–ø—Ä–æ—Å–µ –ø—Ä–∏–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ–≥–æ —Å–æ–æ–±—â–µ–Ω–∏—è –ø–æ—Å–ª–µ –æ–ø–ª–∞—Ç—ã.');
  }
});

bot.action('buy', async (ctx) => {
  await ctx.answerCbQuery();
  const userId = String(ctx.from.id);
  const chatId = String(ctx.chat.id);

  try {
    console.log(`[BUY] Processing for user ${userId}`);
    await User.updateOne({ userId }, { lastActivity: new Date() });
    const user = await User.findOne({ userId });
    if (!user.email) {
      ctx.session = ctx.session || {};
      ctx.session.waitingForEmail = true;
      await ctx.reply('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –≤–∞—à email –¥–ª—è –æ—Ñ–æ—Ä–º–ª–µ–Ω–∏—è –æ–ø–ª–∞—Ç—ã:');
      return;
    }
    await processPayment(ctx, userId, chatId);
  } catch (error) {
    console.error(`[BUY] Error for user ${userId}:`, error.message);
    await ctx.reply('–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.');
  }
});

bot.action('about', async (ctx) => {
  await ctx.answerCbQuery();
  const userId = String(ctx.from.id);
  const chatId = String(ctx.chat.id);
  try {
    console.log(`[ABOUT] Processing for user ${userId}`);
    await User.updateOne({ userId }, { lastActivity: new Date() });
    const settings = await getSettings();
    ctx.session = ctx.session || {};

    const replyMarkup = { inline_keyboard: [[{ text: '‚Ü©Ô∏è –ù–∞–∑–∞–¥', callback_data: 'back' }]] };
    let messageId = ctx.message?.message_id || ctx.session.currentMessageId;

    if (messageId) {
      try {
        await ctx.telegram.editMessageText(chatId, messageId, undefined, settings.channelDescription, {
          parse_mode: 'Markdown',
          reply_markup: replyMarkup,
        });
        ctx.session.currentMessageId = messageId;
        console.log(`[ABOUT] Edited message ${messageId} for user ${userId}`);
      } catch (editError) {
        console.warn(`[ABOUT] Failed to edit message ${messageId} for user ${userId}:`, editError.message);
        const sentMessage = await ctx.replyWithMarkdown(settings.channelDescription, { reply_markup: replyMarkup });
        ctx.session.currentMessageId = sentMessage.message_id;
        console.log(`[ABOUT] Sent new message ${ctx.session.currentMessageId} for user ${userId}`);
      }
    } else {
      console.warn(`[ABOUT] No valid message_id for user ${userId}, sending new message`);
      const sentMessage = await ctx.replyWithMarkdown(settings.channelDescription, { reply_markup: replyMarkup });
      ctx.session.currentMessageId = sentMessage.message_id;
      console.log(`[ABOUT] Sent new message ${ctx.session.currentMessageId} for user ${userId}`);
    }
  } catch (error) {
    console.error(`[ABOUT] Error for user ${userId}:`, error.stack);
    await ctx.reply('–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ –ø–æ–∑–∂–µ.');
  }
});

bot.on('text', async (ctx) => {
  const userId = String(ctx.from.id);
  ctx.session = ctx.session || {};

  try {
    console.log(`[TEXT] Processing text input for user ${userId}: ${ctx.message.text}`);
    await User.updateOne({ userId }, { lastActivity: new Date() });
    const text = ctx.message.text.trim();

    if (ctx.session.waitingForEmail) {
      const emailRegex = /^[^\s@]+@[^\s@]+\.[^\s@]+$/;
      if (!emailRegex.test(text)) return ctx.reply('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤–≤–µ–¥–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π email (–Ω–∞–ø—Ä–∏–º–µ—Ä, user@example.com):');
      await User.updateOne({ userId }, { email: text });
      ctx.session.waitingForEmail = false;
      await ctx.reply('Email —Å–æ—Ö—Ä–∞–Ω—ë–Ω! –ü–µ—Ä–µ—Ö–æ–∂—É –∫ —Å–æ–∑–¥–∞–Ω–∏—é –ø–ª–∞—Ç–µ–∂–∞...');
      return await processPayment(ctx, userId, String(ctx.chat.id));
    }

    if (!adminIds.has(userId) || !ctx.session.editing) return;

    if (ctx.session.editing === 'channelDescription') {
      if (text.length < 10) return ctx.reply('–û–ø–∏—Å–∞–Ω–∏–µ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –Ω–µ –∫–æ—Ä–æ—á–µ 10 —Å–∏–º–≤–æ–ª–æ–≤. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞:');
      await Settings.findOneAndUpdate({}, { channelDescription: text }, { upsert: true, new: true });
      await resetSettingsCache();
      console.log(`[SETTINGS] Updated channelDescription for user ${userId}`);
      ctx.session.editing = null;
      await ctx.reply('–û–ø–∏—Å–∞–Ω–∏–µ –∫–∞–Ω–∞–ª–∞ –æ–±–Ω–æ–≤–ª–µ–Ω–æ!');
    } else if (ctx.session.editing === 'supportLink') {
      let supportLink = text;
      if (supportLink.startsWith('@')) supportLink = `https://t.me/${supportLink.slice(1)}`;
      else if (!supportLink.match(/^https?:\/\//)) return ctx.reply('–í–≤–µ–¥–∏—Ç–µ –¥–µ–π—Å—Ç–≤–∏—Ç–µ–ª—å–Ω—ã–π URL –∏–ª–∏ Telegram-username (–Ω–∞–ø—Ä–∏–º–µ—Ä, @Username). –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞:');
      await Settings.findOneAndUpdate({}, { supportLink }, { upsert: true, new: true });
      await resetSettingsCache();
      console.log(`[SETTINGS] Updated supportLink for user ${userId}`);
      ctx.session.editing = null;
      await ctx.reply('–°—Å—ã–ª–∫–∞ –Ω–∞ —Ç–µ—Ö–ø–æ–¥–¥–µ—Ä–∂–∫—É –æ–±–Ω–æ–≤–ª–µ–Ω–∞!');
    } else if (ctx.session.editing === 'welcomeMessage') {
      if (text.length < 10) return ctx.reply('–ü—Ä–∏–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –Ω–µ –∫–æ—Ä–æ—á–µ 10 —Å–∏–º–≤–æ–ª–æ–≤. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞:');
      await Settings.findOneAndUpdate({}, { welcomeMessage: text }, { upsert: true, new: true });
      await resetSettingsCache();
      console.log(`[SETTINGS] Updated welcomeMessage for user ${userId}`);
      ctx.session.editing = null;
      await ctx.reply('–ü—Ä–∏–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –æ–±–Ω–æ–≤–ª–µ–Ω–æ!');
    } else if (ctx.session.editing === 'paymentAmount') {
      const amount = parseFloat(text);
      if (isNaN(amount) || amount < 1 || amount > 100000) return ctx.reply('–°—É–º–º–∞ –¥–æ–ª–∂–Ω–∞ –±—ã—Ç—å –æ—Ç 1 –¥–æ 100000 —Ä—É–±–ª–µ–π.');
      await Settings.findOneAndUpdate({}, { paymentAmount: amount }, { upsert: true, new: true });
      await resetSettingsCache();
      console.log(`[SETTINGS] Updated paymentAmount to ${amount} for user ${userId}`);
      ctx.session.editing = null;
      await ctx.reply(`–°—É–º–º–∞ –æ–ø–ª–∞—Ç—ã –æ–±–Ω–æ–≤–ª–µ–Ω–∞ –Ω–∞ ${amount} —Ä—É–±.!`);
    } else if (ctx.session.editing === 'paidWelcomeMessage') {
      if (text.length < 10) return ctx.reply('–ü—Ä–∏–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ—Å–ª–µ –æ–ø–ª–∞—Ç—ã –¥–æ–ª–∂–Ω–æ –±—ã—Ç—å –Ω–µ –∫–æ—Ä–æ—á–µ 10 —Å–∏–º–≤–æ–ª–æ–≤. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞:');
      await Settings.findOneAndUpdate({}, { paidWelcomeMessage: text }, { upsert: true, new: true });
      await resetSettingsCache();
      console.log(`[SETTINGS] Updated paidWelcomeMessage for user ${userId}`);
      ctx.session.editing = null;
      await ctx.reply('–ü—Ä–∏–≤–µ—Ç—Å—Ç–≤–µ–Ω–Ω–æ–µ —Å–æ–æ–±—â–µ–Ω–∏–µ –ø–æ—Å–ª–µ –æ–ø–ª–∞—Ç—ã –æ–±–Ω–æ–≤–ª–µ–Ω–æ!');
    }
  } catch (error) {
    console.error(`[TEXT] Error processing text input for user ${userId}:`, error.stack);
    await ctx.reply('–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ—Ö—Ä–∞–Ω–µ–Ω–∏–∏ –∏–∑–º–µ–Ω–µ–Ω–∏–π. –ü–æ–ø—Ä–æ–±—É–π—Ç–µ —Å–Ω–æ–≤–∞.');
  }
});

module.exports = { processPayment };